package project.PSO;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import org.cloudsimplus.cloudlets.Cloudlet;
import org.cloudsimplus.vms.Vm;
import net.sourceforge.jswarm_pso.Particle;

/**
 * Custom implementation of the particle for the virtual machine scheduling problem.
 */
public class PSOParticle extends Particle {

    static int CLOUDLET_SIZE = 0;

    /**
     * Particle constructor.
     */
    public PSOParticle(){
        super(CLOUDLET_SIZE);
    }
 
    /**
     * Maps a list of Cloudlets to a list of VMs based on particle positions.
     * 
     * This method takes a list of Cloudlets and a list of VMs, using the positions generated by the
     * optimization algorithm (stored in `particlePositions`) to map each Cloudlet to a specific VM.
     * The mapping is returned as a HashMap, where each Cloudlet is associated with its
     * corresponding VM based on its position.
     * 
     * @param cloudletList List of Cloudlet objects to be mapped to the VMs.
     * @param vmList List of Vm objects to which the Cloudlets will be assigned.
     * 
     * @return A Map that assigns each Cloudlet in the list to a Vm according to the calculated
     *         positions.
     * 
     * @throws IllegalArgumentException If the size of `particlePositions` does not match the size
     *         of the `cloudletList`, or if a VM index is out of bounds in the `vmList`.
     */
    public Map<Cloudlet, Vm> mapCloudletsToVms(List<Cloudlet> cloudletList, List<Vm> vmList) {
        Map<Cloudlet, Vm> cloudletToVmMap = new HashMap<Cloudlet, Vm>();
        double[] particlePositions = this.getBestPosition();

        // Validación de tamaños
        if (particlePositions.length != cloudletList.size()) {
            throw new IllegalArgumentException(
                "El tamaño de las posiciones no coincide con el tamaño de la lista de cloudlets.");
        }

        for (int cloudletIndex = 0; cloudletIndex < cloudletList.size(); cloudletIndex++) {
            int vmIndex = (int) Math.round(particlePositions[cloudletIndex]);

            // Validación de índices de VM
            if (vmIndex >= vmList.size()) {
                throw new IllegalArgumentException("El índice de la VM " + vmIndex
                        + " está fuera de los límites de la lista de VMs.");
            }

            cloudletToVmMap.put(cloudletList.get(cloudletIndex), vmList.get(vmIndex));
        }

        return cloudletToVmMap;
    }
}
